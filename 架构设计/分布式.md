# 分布式

## 1. id的生成

这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：

（1）全局唯一

（2）趋势有序

**【常见方法一：使用数据库的 auto_increment 来生成全局唯一递增ID】**



**常见方法二：单点批量ID生成服务**



**常见方法三：uuid**

**优点**：

（1）本地生成ID，不需要进行远程调用，时延低

（2）扩展性好，基本可以认为没有性能上限

**缺点**：

（1）无法保证趋势递增

（2）uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）

**常见方法四：取当前毫秒数**

uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？

取当前毫秒数是一种常见方案：uint64 ID = GenTimeMS();

**优点**：

（1）本地生成ID，不需要进行远程调用，时延低

（2）生成的ID趋势递增

（3）生成的ID是整数，建立索引后查询效率高

**缺点**：

（1）如果并发量超过1000，会生成重复的ID

我去，这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题

## 2. CAP

### 满足C和A，那么P能不能满足呢？

满足C需要所有的服务器的数据要一样，也就是说要实现数据的同步，那么同步要不要时间？肯定是要的，并且机器越多，同步的时间肯定越慢，这里问题就来了，我们同时也满足了A，也就是说，我要同步时间短才行。这样的话，机器就不能太多了，也就是说P是满足不了的

### 满足C和P，那么A能不能满足呢？

满足P需要很多服务器，假设有1000台服务器，同时满足了C，也就是说要保证每台机器的数据都一样，那么同步的时间可就很大，在这种情况下，我们肯定是不能保证用户随时访问每台服务器获取到的数据都是最新的，想要获取最新的，你就得等，等全部同步完了，你就可以获取到了，但是我们的A要求短时间就可以拿到想要的数据啊，这不就是矛盾了，所以说这里A是满足不了了

### BASE理论

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。

- 基本可用（Basically Available）

  基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性（注意，这绝不等价于系统不可用）。

- 软状态（Soft State）

  软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

- 最终一致性（Eventually Consistent）

  最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态

## 3.分布式一致性协议

- 两阶段提交协议(2PC)

  - 第一阶段（投票阶段） 协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应,各参与者节点响应协调者节点发起的询问，如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；
    如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息
  - 第二阶段（提交执行阶段）：当协调者节点从所有参与者节点获得的相应消息都为"同意"时,协调者节点向所有参与者节点发出"正式提交"的请求
  - 缺点：
    - 资源被同步阻塞：
    - 在数据提交的过程中，所有参与处理的服务器都处于阻塞状态，如果其他线程想访问临界区的资源，需要等待该条会话请求在本地执行完成后释放临界区资源。因此，采用二阶段提交算法也会降低程序并发执行的效率

- 三阶段提交协议(3PC)

- TCC

- 最终一致性模式

  
