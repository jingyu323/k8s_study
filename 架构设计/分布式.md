# 分布式

## 1. id的生成

这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：

（1）全局唯一

（2）趋势有序

**【常见方法一：使用数据库的 auto_increment 来生成全局唯一递增ID】**



**常见方法二：单点批量ID生成服务**



**常见方法三：uuid**

**优点**：

（1）本地生成ID，不需要进行远程调用，时延低

（2）扩展性好，基本可以认为没有性能上限

**缺点**：

（1）无法保证趋势递增

（2）uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）

**常见方法四：取当前毫秒数**

uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？

取当前毫秒数是一种常见方案：uint64 ID = GenTimeMS();

**优点**：

（1）本地生成ID，不需要进行远程调用，时延低

（2）生成的ID趋势递增

（3）生成的ID是整数，建立索引后查询效率高

**缺点**：

（1）如果并发量超过1000，会生成重复的ID

我去，这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题

## 2. CAP

### 满足C和A，那么P能不能满足呢？

满足C需要所有的服务器的数据要一样，也就是说要实现数据的同步，那么同步要不要时间？肯定是要的，并且机器越多，同步的时间肯定越慢，这里问题就来了，我们同时也满足了A，也就是说，我要同步时间短才行。这样的话，机器就不能太多了，也就是说P是满足不了的

### 满足C和P，那么A能不能满足呢？

满足P需要很多服务器，假设有1000台服务器，同时满足了C，也就是说要保证每台机器的数据都一样，那么同步的时间可就很大，在这种情况下，我们肯定是不能保证用户随时访问每台服务器获取到的数据都是最新的，想要获取最新的，你就得等，等全部同步完了，你就可以获取到了，但是我们的A要求短时间就可以拿到想要的数据啊，这不就是矛盾了，所以说这里A是满足不了了

### BASE理论

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。

- 基本可用（Basically Available）

  基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性（注意，这绝不等价于系统不可用）。

- 软状态（Soft State）

  软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

- 最终一致性（Eventually Consistent）

  最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态

## 3.分布式一致性协议

- 两阶段提交协议(2PC)

  - 第一阶段（投票阶段） 协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应,各参与者节点响应协调者节点发起的询问，如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；
    如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息
  - 第二阶段（提交执行阶段）：当协调者节点从所有参与者节点获得的相应消息都为"同意"时,协调者节点向所有参与者节点发出"正式提交"的请求
  - 单点问题：还会发生单点问题。单点问题也叫作单点服务器故障问题，它指的是当作为分布式集群系统的调度服务器发生故障时，整个集群因为缺少协调者而无法进行二阶段提交算法
  - 缺点：
    - 资源被同步阻塞：
    - 在数据提交的过程中，所有参与处理的服务器都处于阻塞状态，如果其他线程想访问临界区的资源，需要等待该条会话请求在本地执行完成后释放临界区资源。因此，采用二阶段提交算法也会降低程序并发执行的效率
  - 

- 三阶段提交协议(3PC)

  - 第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。
  - 一旦进入阶段3，发生 协调者出现问题 或 协调者和参与者之间的网络出现故障，即参与者无法及时接收到来自协调者的 DoCommit 或 abort 请求，针对这种异常情况，参与者都会在等待超时之后，继续进行事务提交
  - 缺点：参与者接收到 PreCommit 消息后，如果网络出现分区，此时协调者和部分参与者无法进行正常的网络通信，该部分参与者依然会进行事务的提交，必然出现数据的不一致性。

- TCC

  - TCC 将事务的提交过程分为 try-confirm-cancel(实际上 TCC 就是 try、confirm、cancel 的简称) 三个阶段:
    - try：完成业务检查、预留业务资源
    - confirm：使用预留的资源执行业务操作（需要保证幂等性）
    - cancel：取消执行业务操作，释放预留的资源（需要保证幂等性）
  - 流程如下：
    - 事务发起方向事务协调器发起事务请求，事务协调器调用所有事务参与者的 try 方法完成资源的预留，这时候并没有真正执行业务，而是为后面具体要执行的业务预留资源，这里完成了一阶段。
    - 如果事务协调器发现有参与者的 try 方法预留资源时候发现资源不够，则调用参与方的 cancel 方法回滚预留的资源，需要注意 cancel 方法需要实现业务幂等，因为有可能调用失败（比如网络原因参与者接受到了请求，但是由于网络原因事务协调器没有接受到回执）会重试。
    - 如果事务协调器发现所有参与者的 try 方法返回都 OK，则事务协调器调用所有参与者的 confirm 方法，不做资源检查，直接进行具体的业务操作。
    - 如果协调器发现所有参与者的 confirm 方法都 OK 了，则分布式事务结束。
    - 如果协调器发现有些参与者的 confirm 方法失败了，或者由于网络原因没有收到回执，则协调器会进行重试。这里如果重试一定次数后还是失败，常见的是做事务补偿。

- 最终一致性模式

  
