# 网络知识

## 1.OSI网络体系结构和TCP/IP协议结构

OSI网络体系结构分为七层：

从下到上分为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

TCP/IP协议结构分为四层：

从下到上分为：网络接口层、网际层、传输层、应用层

常见的[网络层](https://so.csdn.net/so/search?q=网络层&spm=1001.2101.3001.7020)次划分：`TCP/IP四层模型`、`TCP/IP五层模型`、`OSI七层模型`

- `TCP/IP四层模型`:网络接口层、网络层、传输层、应用层
- `TCP/IP五层模型`:`物理层`、`数据链路层`、网络层、传输层、应用层
- `OSI七层模型`:物理层、数据链路层、网络层、传输层、`会话层`、`表示层`、应用层

##### OSI七层模型

> TCP/IP协议时互联网的基础协议，任何和互联网有关的操作都狸奴开TCP/IP协议

1. `物理层`(Physical Layer):物理层确保原始的数据可在各种物理媒体上传输，两个重要设备名称，中继器和集线器

2. ```
   数据链路层
   ```

   (Data Link Layer):最基本的服务是将源自网络层的数据可靠的传输到相邻节点的目标网络层，作用：物理地址寻址、数据的成帧、数据的检错、重发等

   有关数据链路层的知识点：

   1. 数据链路层为网络层提供可靠的数据传输
   2. 基本数据单位为帧
   3. 主要的协议：以太网协议
   4. 两个重要的设备名称：网桥和交换机

3. ```
   网络层
   ```

   (Network Layer):实现两个端系统之间的数据透明传输，具体功能包括寻址、路径选择、连接的建立、保持和终止等。IP协议：仅仅提供不可靠、无连接的传送服务，主要功能有无连接数据报传输、数据报路由选择和差错控制

   重点知识：

   1. 网络层负责对子网间的数据包进行路由选择，可以是吸纳拥塞控制、网际互连等功能
   2. 基本数据单位为IP数据报
   3. 包含的主要协议：
      `IP协议`(Internet Protecal)：因特网互联协议
      `ICMP协议`(Internet Control Message protocol):因特网控制报文协议
      `ARP协议`(Address Resolution Protocol):地址解析协议
      `RARP协议`(Reverse Address Resolution protocol):逆地址解析协议
   4. 重要的设备：路由器

4. ```
   传输层
   ```

   (Transport Layer):负责将上层数据分段并提供端到端、可靠的和不可靠的传输，还要处理端到端的差错控制和流量控制问题

   有关的重点：

   1. 传输层将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题
   2. 包含的主要协议：TCP协议(Transmission Control Protocol,传输控制协议)、UDP(User Datagram Protocol, 用户数据报协议)
   3. 重要设备：网关

5. `会话层`：管理主机之间的会话进程，即负责建立、管理、中值进程间的会话，会话层还在数据中插入校验点来实现数据的同步

6. `表示层`:对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解，表示层的数据转换包括数据的加密、压缩、格式转换等

7. `应用层`：为操作系统或网络应用程序提供访问网络服务的接口
   会话层、表示层和应用层重点：

   1. 数据传输基本单位为报文
   2. 包含的束腰协议：FTP(文件传送协议)、Telnet(远程登录协议)、DNS(域名解析协议)、SMTP(邮件传送协议)、POP3(邮局协议)、HTTP协议

## 3.IP地址

1. 网络地址：IP地址由网络号和主机号组成，网络地址的主机号全为0，网络地址代表着整个网络
2. 广播地址：也称为直接广播地址，是为了区分受限广播地址，广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1，当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息
3. 组播地址：

`ABCD类地址`：

- A类地址以0开头，第一个字节作为网络号，地址范围：0.0.0.0~127.255.255.255

- B类地址以10开头，前面两个字节作为网络号，地址范围：128.0.0.0~191.255.255.255

- C类地址以110开头，前面三个字节作为网络号，地址范围：192.0.0.0~223.255.255.255

- D类地址以1110开头，地址范围224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多通信）

- E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255
  只有ABC有网络号和主机号之分

  ##### IP和子网掩码

  `IP`由四段数字组成，3类常用的IP
  A类IP段：0.0.0.0. 到127.255.255.255
  B类IP段：127.0.0.0 到191.255.255.255
  C类字段：192.0.0.0 到223.255.255.255
  `子网掩码`：
  A类的IP段：255.0.0.0   一个子网最多容纳1677万台主机
  B类的IP段：255.255.0.0   一个子网最多容纳6万台主机

  C类的IP段：255.255.255.0   一个子网最多容纳254台(最后一位不能使0和255， 2^8-2=254)主机

  子网掩码决定了一个子网计算机的数目，计算公式是2的n次方，例如子网掩码255.255.255.0，转换二进制11111111.11111111.11111111.00000000 前面为1的表示网络数，后面为0的表示主机数，也就是后面0的数量决定了主机的个数，具体主机个数是2^8次方256个，但是有两个`IP`不能用那就是最后一段不能为0和255，所以是254台
  也可以通过主机数来逆向推算出子网掩码

  ```
  1.一个公司有530台电脑，设置子网掩码
  先确定使用哪类IP较合适，显然是B类（A类太多，浪费，C类太少，不够）
  2^9 < 530 < 2^10，所以子网掩码后面0的个数设为10个较为合适
  则相应的子网掩码对应的二进制为11111111.11111111.11111100.00000000
  转换成10进制为255.255.252.0
  ```

  附：192.168.1.0/26 /26表示子网掩码前26位全为1，即对应的子网掩码为255.255.255.192，对应的二进制为11111111.11111111.11111111.11000000

  `判断是否在同一网段`
  `网络标志`：A类的只算第一段、B类的只算第一、二段、C类的只算第一、二、三段
  将IP和子网掩码化为二进制文件，然后做与运算，得出的结果就是网络标识（重点看子网掩码的`网络号`）。
  `主机标识`：将子网掩码取反，然后和IP做与运算

  ```
  A IP:202.194.128.9
  B IP:202.194.128.14
  子网掩码：255.255.255.0
  1.转换成二进制：
  A：1100 1010.1100 0010.1000 0000.0000 1001
  B：1100 1010.1100 0010.1000 0000.0000 1101
  掩码：1111 1111.1111 1111. 1111 1111 .0000 0000
  2.A、BIP与掩码做与运算
  A：11001010.1100 0010.1000 0000 .0000 0000 转换成十进制 202.194.128.0
  B: 1100 1010.1100 0010.1000 0000.0000 0000 转换成十进制 202.194.128.0
  两个网络标识IP相同，说明在同一子网
  3.计算主机标识：
  将掩码取反：0000 0000.0000 0000.0000 0000.1111 1111
  然后再再做与运算，得
  A：0000 0000.0000 0000.0000 0000.0000 1001 转换成十进制为 9
  B：0000 0000.0000 0000.0000 0000.0000 1101 转换成十进制为14
  ```

  ### 子网掩码及网络划分
  
  　　随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。
  
  　　这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。
  
  　　**什么是子网掩码？**
  
  　　子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。
  
  　　**在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。**
  
  　　**子网掩码的计算：**
  
  　　对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。
  
  　　下面总结一下有关子网掩码和网络划分常见的面试考题：
  
  　　**1）利用子网数来计算**
  
  　　在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。
  
  　　(1) 将子网数目转化为二进制来表示;
  
  　　如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；
  
  　　(2) 取得该二进制的位数，为N；
  
  　　该二进制为五位数，N = 5
  
  　　(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。
  
  　　将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0
  
  　　**2）利用主机数来计算**
  
  　　如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：
  
  　　(1) 将主机数目转化为二进制来表示；
  
  　　700=1010111100；
  
  　　(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N<8。如果大于254，则 N>8，这就是说主机地址将占据不止8位；
  
  　　该二进制为十位数，N=10；
  
  　　(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。
  
  　　将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。
  
  　　**3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和****计算子网掩码。这也可按上述原则进行计算。**
  
  　　比如一个子网有10台主机，那么对于这个子网需要的IP地址是：
  
  　　10＋1＋1＋1＝13
  
  　　**注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网****络地址和广播地址。**
  
  　　因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。
  
  　　如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。
  
  [回到顶部](https://www.cnblogs.com/maybe2030/p/4781555.html#_labelTop)
  
  ### 5. ARP/RARP协议
  
  　　**地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。**主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。**ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。**
  
  　　ARP工作流程举例：
  
  　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
  
  　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
  
  　　当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
  
  　　（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
  
  　　（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
  
  　　（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
  
  　　（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
  
  　　（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。
  
  　　**逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址**，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。
  
  　　RARP协议工作流程：
  
  　　（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
  
  　　（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
  
  　　（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
  
  　　（4）如果不存在，RARP服务器对此不做任何的响应；
  
  　　（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。
  
  [回到顶部](https://www.cnblogs.com/maybe2030/p/4781555.html#_labelTop)
  
  ### 6. 路由选择协议
  
  　　常见的路由选择协议有：RIP协议、OSPF协议。
  
  　　**RIP****协议** ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。
  
  　　**OSPF****协议** ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。

## 4.TCP协议的三次握手和四次挥手

##### 三次握手：

第一次握手：建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。


第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=x+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

##### 四次挥手：

 第一次挥手：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。


第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。


第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

### 4.1 为什么连接的时候是三次握手，关闭的时候却是4次挥手 

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

总结：确认ack和FIN报文不能同时发导致的。

### 4.2为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### 4.3为什么要用三次握手而不是两次或四次

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，当第二次握手后（即服务器发送给客户端）的请求客户端没收到时，服务器会认为已经建立了连接，开始发送数据，但是客户端没收到连接请求，会认为连接未建立，继续发送连接信息。这时就导致了死锁。

至于为什么不改成四次，当三次连接后，服务器和客户机都能确定之前的通信情况，但是无法确认之后的情况，可靠的通信协议是根本不存在的，因此再增加一次也是徒劳。

### 4.4 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后**每隔75秒钟**发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

 

## 5.常见的网络攻击方式？以及预防措施

### 5.1 DDoS

DDoS攻击

DDoS全称Distributed Denial of Service，中文意思为“分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

常见的攻击方式如TCP攻击：

客户端向服务端发送请求链接数据包

服务端向客户端发送确认数据包

客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

DDoS预防

限制同时打开SYN半链接的数目

缩短SYN半链接的Time out 时间

关闭不必要的服务

### 5.2 SQL注入

SQL注入

攻击者不是将标准数据提交到文本框或其他数据输入字段，而是输入SQL语句来诱骗应用程序显示或操纵其数据。

SQL注入预防措施

不要使用动态SQL

不要将敏感数据保留在纯文本中。

限制数据库权限和特权

避免直接向用户显示数据库错误

对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）

定期测试与数据库交互的Web应用程序

将数据库更新为最新的可用修补程序

### 5.3 XSS攻击

XSS 攻击

XSS 攻击，即跨站脚本攻击（Cross Site Scripting），它是 web 程序中常见的漏洞。  攻击者破坏易受攻击的网站或Web应用程序并注入恶意代码。当页面加载时，代码在用户的浏览器上执行恶意脚本。

XSS预防

web 页面用户输入的地方，对输入的数据转义、过滤处理。后台输出页面的时候，也需要对输出内容进行转义、过滤处理（因为攻击者可能通过其他方式把恶意脚本写入数据库）

前端对 html 标签属性、css 属性赋值的地方进行校验

### 5.4 CSRF攻击

CSRF 攻击

跨站请求伪造（英语：Cross-site request forgery），是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

CSRF预防

检查Referer字段

HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。

添加校验token

由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。

### 5.5 请简述ping一下的原理

`ping`是利用网络上机器IP地址的唯一性，给目标IP地址发送一个` ICMP `回显请求，并要求对方返回一个 `ICMP` 回显应答来确定两台网络机器是否连接相通，时延是多少。一般用于检测网络通与不通 ，时延值越大，速度越慢。

### 5.6 从浏览器输入URL到将页面渲染出来，发生了什么?

1.首先，在浏览器地址栏中输入URL，先`解析URL`，检测URL地址是否合法；

2.浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第3步操作。

`浏览器缓存`：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；

`路由器缓存`：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；

`ISP缓存`：若上述均失败，继续向ISP搜索。

3.在发送http请求前，需要`域名解析`(DNS解析)，解析获取相应的IP地址。

4.浏览器向服务器发起TCP连接，与浏览器建立`TCP三次握手`。

5.握手成功后，浏览器向服务器`发送HTTP请求`，请求数据包。

6.服务器处理收到的请求，`将数据返回至浏览器`。

7.浏览器收到HTTP响应。

8.浏览器解码响应，如果响应可以缓存，则`存入缓存`。

9.浏览器发送`请求获取嵌入在HTML中的资源`（HTML，CSS，JavaScript，图片，音乐······），对于未知类型，会弹出对话框。

10.`浏览器发送异步请求`。

11.`页面全部渲染结束`。



### 5.7 网页突然加载不出来，可能导致的原因有哪些？

1.`网络`断开了；

2.`后端页面`无法加载；

3.`网页`被劫持了；

4.`DNS`无法解析网址；

5.`服务器`负载过大；

6.`代理`设置问题；

7.`电脑配置`太低；

9.`CPU`,`内存`被占满；

10.`SQL`查询数据太多，加载不出来；



## 6.网络协议

`OSICMP协议`：**因特网控制报文协议**，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。

`TFTP协议`：是TCP/IP协议族中的一个用来在客户机与服务器之间进行**简单文件传输的协议**，提供不复杂、开销不大的文件传输服务。



端口是一个软件结构，被客户程序或服务进程用来发送和接收信息。一个端口对应一个16比特的数。服务进程通常使用一个固定的端口，例如，SMTP使用25、Xwindows使用6000。Tomcat的端口：8080，这些端口号是‘广为人知’的，因为在建立与特定的主机或服务的连接时，需要这些地址和目的地址进行通讯，列如我们去建立聊天通讯的指定的自定义端口（8090）。

###  数据格式

数据帧：帧头+IP数据包+帧尾 （帧头包括源和目标主机MAC初步地址及类型，帧尾是校验字）
IP数据包：IP头部+TCP数据信息（IP头包括源和目标主机IP地址、类型、生存期等）
TCP数据信息：TCP头部+实际数据 (TCP头包括源和目标主机端口号、顺序号、确认号、校验字等）
常见的以太帧结构 



##### 丢包

我们在上述的讨论过程中描绘了一个公式那就是 La/R 不能大于1，如果 La/R 大于1，那么到达的排队将会无穷大，而且路由器中的排队队列所容纳的分组是有限的，所以等到路由器队列堆满后，新到达的分组就无法被容纳，导致路由器 丢弃(drop) 该分组，即分组会 丢失(lost)。

计算机网络中的吞吐量
除了丢包和时延外，衡量计算机另一个至关重要的性能测度是端到端的吞吐量。假如从主机 A 向主机 B 传送一个大文件，那么在任何时刻主机 B 接收到该文件的速率就是 瞬时吞吐量(instantaneous throughput)。如果该文件由 F 比特组成，主机 B 接收到所有 F 比特用去 T 秒，则文件的传送平均吞吐量(average throughput) 是 F / T bps。 



##### 地址解析协议ARP

当我们知道了一个主机或路由器的IP地址，如何找出其相应的硬件地址呢？

地址解析协议ARP就是用来解决这样的问题的。
IP协议使用了ARP协议，所以通常就把ARP协议划归为网络层。（RARP）逆地址解析协议。将物理地址转化为IP地址。但是现在的DHCP协议也有此功能。

IP地址和物理地址因为格式不同（IP地址有32位，局域网的物理地址48位）不存在简单的映射关系。

当新主机加入，撤走一些主机或更换网络适配器也会是主机的硬件地址发生改变。
ARP为了解决这个问题实在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。

每一台主机都设有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是主机目前知道的一些地址，那么主机是怎样知道这些地址的呢？
可见数据在本局域网上的传输使用的是MAC地址。

当A要向本局域网上的某台主机B发送IP数据报时，现在其ARP高速缓存中查找是否有B的IP地址，有就在ARP高速缓存中查找其对应的硬件地址，再把这个硬件地址写入MAC帧中，然后通过局域网把该MAC帧发往此硬件地址。

如果查不到该主机的IP地址。
主机A的ARP进程会在本局域网广播一个ARP请求分组，里面包含A的IP地址和物理地址，和想得到主机B的IP地址。本局域网上的所有主机运行的ARP进程都会收到这个ARP请求分组。主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个分组将其IP地址和物理地址写入ARP高速缓存中，并且向主机A发送ARP响应分组。注意：ARP响应分组时普通的单播，即从一个源地址到一个目的地址。

ARP对保存在高速缓存中的每一个映射地址项目都设有生存时间。ARP解决了同一个局域网的主机或路由器的IP地址和硬件地址的映射问题。

当主机A跟另一个网络的主机B通信时，主机A只需要找到本局域网路由器的物理地址即可，剩下工作交给路由器来完成。（路由器最少处于两个网络中，因此路由器具有多个IP地址）

既然在网络链路上传送的帧最终都是按照硬件地址找到目的主机的，那为什么我们还要使用抽象的IP地址呢?直接使用硬件地址进行通信不就完了。
由于全世界存在着各式各样的网络，他们使用不同的硬件地址。要使这些异构的网络能够互相通信，就必须进行非常复杂的硬件地址转换工作。
但是IP编址就把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的IP地址，他们之间的通信仿佛就连接在同一个网络那样简单方便。
因此虚拟的IP网络上用的IP地址进行通信，给广大计算机用户带来了很大的方便。

##### 参考材料

https://blog.csdn.net/jiahuan_/article/details/108938107

## 7.常见的网络问题

### 7.1 请简述ping一下的原理

`ping`是利用网络上机器IP地址的唯一性，给目标IP地址发送一个` ICMP `回显请求，并要求对方返回一个 `ICMP` 回显应答来确定两台网络机器是否连接相通，时延是多少。一般用于检测网络通与不通 ，时延值越大，速度越慢。

### 7.2 从浏览器输入URL到将页面渲染出来，发生了什么?

1.首先，在浏览器地址栏中输入URL，先`解析URL`，检测URL地址是否合法；

2.浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第3步操作。

`浏览器缓存`：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；

`路由器缓存`：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；

`ISP缓存`：若上述均失败，继续向ISP搜索。

3.在发送http请求前，需要`域名解析`(DNS解析)，解析获取相应的IP地址。

4.浏览器向服务器发起TCP连接，与浏览器建立`TCP三次握手`。

5.握手成功后，浏览器向服务器`发送HTTP请求`，请求数据包。

6.服务器处理收到的请求，`将数据返回至浏览器`。

7.浏览器收到HTTP响应。

8.浏览器解码响应，如果响应可以缓存，则`存入缓存`。

9.浏览器发送`请求获取嵌入在HTML中的资源`（HTML，CSS，JavaScript，图片，音乐······），对于未知类型，会弹出对话框。

10.`浏览器发送异步请求`。

11.`页面全部渲染结束`。



### 7.3  网页突然加载不出来，可能导致的原因有哪些？

1.`网络`断开了；

2.`后端页面`无法加载；

3.`网页`被劫持了；

4.`DNS`无法解析网址；

5.`服务器`负载过大；

6.`代理`设置问题；

7.`电脑配置`太低；

9.`CPU`,`内存`被占满；

10.`SQL`查询数据太多，加载不出来；







# 参考

https://www.cnblogs.com/maybe2030/p/4781555.html#_label1