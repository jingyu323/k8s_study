# 网络知识

## 1.OSI网络体系结构和TCP/IP协议结构

OSI网络体系结构分为七层：

从下到上分为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

TCP/IP协议结构分为四层：

从下到上分为：网络接口层、网际层、传输层、应用层

常见的[网络层](https://so.csdn.net/so/search?q=网络层&spm=1001.2101.3001.7020)次划分：`TCP/IP四层模型`、`TCP/IP五层模型`、`OSI七层模型`

- `TCP/IP四层模型`:网络接口层、网络层、传输层、应用层
- `TCP/IP五层模型`:`物理层`、`数据链路层`、网络层、传输层、应用层
- `OSI七层模型`:物理层、数据链路层、网络层、传输层、`会话层`、`表示层`、应用层

##### OSI七层模型

> TCP/IP协议时互联网的基础协议，任何和互联网有关的操作都狸奴开TCP/IP协议

1. `物理层`(Physical Layer):物理层确保原始的数据可在各种物理媒体上传输，两个重要设备名称，中继器和集线器

2. ```
   数据链路层
   ```

   (Data Link Layer):最基本的服务是将源自网络层的数据可靠的传输到相邻节点的目标网络层，作用：物理地址寻址、数据的成帧、数据的检错、重发等

   有关数据链路层的知识点：

   1. 数据链路层为网络层提供可靠的数据传输
   2. 基本数据单位为帧
   3. 主要的协议：以太网协议
   4. 两个重要的设备名称：网桥和交换机

3. ```
   网络层
   ```

   (Network Layer):实现两个端系统之间的数据透明传输，具体功能包括寻址、路径选择、连接的建立、保持和终止等。IP协议：仅仅提供不可靠、无连接的传送服务，主要功能有无连接数据报传输、数据报路由选择和差错控制

   重点知识：

   1. 网络层负责对子网间的数据包进行路由选择，可以是吸纳拥塞控制、网际互连等功能
   2. 基本数据单位为IP数据报
   3. 包含的主要协议：
      `IP协议`(Internet Protecal)：因特网互联协议
      `ICMP协议`(Internet Control Message protocol):因特网控制报文协议
      `ARP协议`(Address Resolution Protocol):地址解析协议
      `RARP协议`(Reverse Address Resolution protocol):逆地址解析协议
   4. 重要的设备：路由器

4. ```
   传输层
   ```

   (Transport Layer):负责将上层数据分段并提供端到端、可靠的和不可靠的传输，还要处理端到端的差错控制和流量控制问题

   有关的重点：

   1. 传输层将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题
   2. 包含的主要协议：TCP协议(Transmission Control Protocol,传输控制协议)、UDP(User Datagram Protocol, 用户数据报协议)
   3. 重要设备：网关

5. `会话层`：管理主机之间的会话进程，即负责建立、管理、中值进程间的会话，会话层还在数据中插入校验点来实现数据的同步

6. `表示层`:对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解，表示层的数据转换包括数据的加密、压缩、格式转换等

7. `应用层`：为操作系统或网络应用程序提供访问网络服务的接口
   会话层、表示层和应用层重点：

   1. 数据传输基本单位为报文
   2. 包含的束腰协议：FTP(文件传送协议)、Telnet(远程登录协议)、DNS(域名解析协议)、SMTP(邮件传送协议)、POP3(邮局协议)、HTTP协议

## 3.IP地址

1. 网络地址：IP地址由网络号和主机号组成，网络地址的主机号全为0，网络地址代表着整个网络
2. 广播地址：也称为直接广播地址，是为了区分受限广播地址，广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1，当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息
3. 组播地址：

`ABCD类地址`：

- A类地址以0开头，第一个字节作为网络号，地址范围：0.0.0.0~127.255.255.255

- B类地址以10开头，前面两个字节作为网络号，地址范围：128.0.0.0~191.255.255.255

- C类地址以110开头，前面三个字节作为网络号，地址范围：192.0.0.0~223.255.255.255

- D类地址以1110开头，地址范围224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多通信）

- E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255
  只有ABC有网络号和主机号之分

  ##### IP和子网掩码

  `IP`由四段数字组成，3类常用的IP
  A类IP段：0.0.0.0. 到127.255.255.255
  B类IP段：127.0.0.0 到191.255.255.255
  C类字段：192.0.0.0 到223.255.255.255
  `子网掩码`：
  A类的IP段：255.0.0.0   一个子网最多容纳1677万台主机
  B类的IP段：255.255.0.0   一个子网最多容纳6万台主机

  C类的IP段：255.255.255.0   一个子网最多容纳254台(最后一位不能使0和255， 2^8-2=254)主机

  子网掩码决定了一个子网计算机的数目，计算公式是2的n次方，例如子网掩码255.255.255.0，转换二进制11111111.11111111.11111111.00000000 前面为1的表示网络数，后面为0的表示主机数，也就是后面0的数量决定了主机的个数，具体主机个数是2^8次方256个，但是有两个`IP`不能用那就是最后一段不能为0和255，所以是254台
  也可以通过主机数来逆向推算出子网掩码

  ```
  1.一个公司有530台电脑，设置子网掩码
  先确定使用哪类IP较合适，显然是B类（A类太多，浪费，C类太少，不够）
  2^9 < 530 < 2^10，所以子网掩码后面0的个数设为10个较为合适
  则相应的子网掩码对应的二进制为11111111.11111111.11111100.00000000
  转换成10进制为255.255.252.0
  ```

  附：192.168.1.0/26 /26表示子网掩码前26位全为1，即对应的子网掩码为255.255.255.192，对应的二进制为11111111.11111111.11111111.11000000

  `判断是否在同一网段`
  `网络标志`：A类的只算第一段、B类的只算第一、二段、C类的只算第一、二、三段
  将IP和子网掩码化为二进制文件，然后做与运算，得出的结果就是网络标识（重点看子网掩码的`网络号`）。
  `主机标识`：将子网掩码取反，然后和IP做与运算

  ```
  A IP:202.194.128.9
  B IP:202.194.128.14
  子网掩码：255.255.255.0
  1.转换成二进制：
  A：1100 1010.1100 0010.1000 0000.0000 1001
  B：1100 1010.1100 0010.1000 0000.0000 1101
  掩码：1111 1111.1111 1111. 1111 1111 .0000 0000
  2.A、BIP与掩码做与运算
  A：11001010.1100 0010.1000 0000 .0000 0000 转换成十进制 202.194.128.0
  B: 1100 1010.1100 0010.1000 0000.0000 0000 转换成十进制 202.194.128.0
  两个网络标识IP相同，说明在同一子网
  3.计算主机标识：
  将掩码取反：0000 0000.0000 0000.0000 0000.1111 1111
  然后再再做与运算，得
  A：0000 0000.0000 0000.0000 0000.0000 1001 转换成十进制为 9
  B：0000 0000.0000 0000.0000 0000.0000 1101 转换成十进制为14
  ```

  

## 4.TCP协议的三次握手和四次挥手

##### 三次握手：

第一次握手：建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。


第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=x+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

##### 四次挥手：

 第一次挥手：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。


第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。


第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

### 4.1 为什么连接的时候是三次握手，关闭的时候却是4次挥手 

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

总结：确认ack和FIN报文不能同时发导致的。

### 4.2为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### 4.3为什么要用三次握手而不是两次或四次

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，当第二次握手后（即服务器发送给客户端）的请求客户端没收到时，服务器会认为已经建立了连接，开始发送数据，但是客户端没收到连接请求，会认为连接未建立，继续发送连接信息。这时就导致了死锁。

至于为什么不改成四次，当三次连接后，服务器和客户机都能确定之前的通信情况，但是无法确认之后的情况，可靠的通信协议是根本不存在的，因此再增加一次也是徒劳。

### 4.4 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后**每隔75秒钟**发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

 

## 5.常见的网络攻击方式？以及预防措施

### 5.1 DDoS

DDoS攻击

DDoS全称Distributed Denial of Service，中文意思为“分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

常见的攻击方式如TCP攻击：

客户端向服务端发送请求链接数据包

服务端向客户端发送确认数据包

客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

DDoS预防

限制同时打开SYN半链接的数目

缩短SYN半链接的Time out 时间

关闭不必要的服务

### 5.2 SQL注入

SQL注入

攻击者不是将标准数据提交到文本框或其他数据输入字段，而是输入SQL语句来诱骗应用程序显示或操纵其数据。

SQL注入预防措施

不要使用动态SQL

不要将敏感数据保留在纯文本中。

限制数据库权限和特权

避免直接向用户显示数据库错误

对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）

定期测试与数据库交互的Web应用程序

将数据库更新为最新的可用修补程序

### 5.3 XSS攻击

XSS 攻击

XSS 攻击，即跨站脚本攻击（Cross Site Scripting），它是 web 程序中常见的漏洞。  攻击者破坏易受攻击的网站或Web应用程序并注入恶意代码。当页面加载时，代码在用户的浏览器上执行恶意脚本。

XSS预防

web 页面用户输入的地方，对输入的数据转义、过滤处理。后台输出页面的时候，也需要对输出内容进行转义、过滤处理（因为攻击者可能通过其他方式把恶意脚本写入数据库）

前端对 html 标签属性、css 属性赋值的地方进行校验

### 5.4 CSRF攻击

CSRF 攻击

跨站请求伪造（英语：Cross-site request forgery），是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

CSRF预防

检查Referer字段

HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。

添加校验token

由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。



# 参考

https://www.cnblogs.com/maybe2030/p/4781555.html#_label1