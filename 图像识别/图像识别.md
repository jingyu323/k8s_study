# 图像识别

-- 图像识别技术的过程分以下几步：信息的获取、预处理、特征抽取和选择、分类器设计和分类决策。

 1.信息的获取是指通过传感器，将光或声音等信息转化为电信息。也就是获取研究对象的基本信息并通过某种方法将其转变为机器能够认识的信息。
 2.预处理主要是指图像处理中的去噪、平滑、变换等的操作，从而加强图像的重要特征。
 3.特征抽取和选择是指在模式识别中，需要进行特征的抽取和选择。简单的理解就是我们所研究的图像是各式各样的，如果要利用某种方法将它们区分开，就要通过这些图像所具有的本身特征来识别，而获取这些特征的过程就是特征抽取。在特征抽取中所得到的特征也许对此次识别并不都是有用的，这个时候就要提取有用的特征，这就是特征的选择。特征抽取和选择在图像识别过程中是非常关键的技术之一，所以对这一步的理解是图像识别的重点。
 4.分类器设计是指通过训练而得到一种识别规则，通过此识别规则可以得到一种特征分类，使图像识别技术能够得到高识别率。分类决策是指在特征空间中对被识别对象进行分类，从而更好地识别所研究的对象具体属于哪一类。

预处理算法：滤波；图像增强；图像分割；预处理算法结果：构成训练样本和测试样本；
特征  提取：形状进行归一化处理；提取各阶矩特征值；特征值进行归一化处理；训练SVM得参数设计电气设备的分类器；

 神经网络图像识别技术是一种比较新型的图像识别技术，是在传统的图像识别方法和基础上融合神经网络算法的一种图像识别方法。
 在对车牌上的字符进行识别的过程中就用到了基于模板匹配算法和基于人工神经网络算法。想让计算机具有高效地识别能力，最直接有效的方法就是降维。降维分为线性降维和非线性降维。例如主成分分析（PCA）和线性奇异分析（LDA）等就是常见的线性降维方法，它们的特点是简单、易于理解。

# 1.OpenCV

适用范围：

OpenCV用来做图像处理，定位到身份证号码的区域

安装：

## 1. 图像的仿射变换

#### 透视变换

可以将图像从一个透视投影转换为另一个透视投影，实现图像的旋转、缩放、平移等操作

#### 单应性矩阵

```
该函数可以根据输入的坐标获取透视变换后的坐标
findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask[, maxIters[, confidence]]]]]) -> H, mask
（ M = cv2.getPerspectiveTransform(src,dst) 该函数也可以获取透视变换矩阵）
计算多个二维点对之间的最优单应性矩阵 H（3行x3列） ，使用最小均方误差或者RANSAC方法。函数功能：找到两个平面之间的转换矩阵。
```

```

该函数可以根据输入的坐标获取透视变换后的坐标
warpPerspective(src, H, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst

（ dst = cv2.perspectiveTransform(pts,H) ）

通过输入变换矩阵得到透视图片。

参数说明：

src 输入图片；dst 输出图片。
M 输入的透视变换矩阵，大小是3*3
dsize 输出图片的大小
flags 插值方法（INTER_LINEAR或INTER_NEAREST）与可选标志WARP_INVERSE_MAP的组合，将M设置为逆变换（𝚍𝚜𝚝→𝚜𝚛𝚌）。
borderMode 边界像素赋值操作(BORDER_CONSTANT or BORDER_REPLICATE)，前者是定值，后者是复制周围像素。
```









## 卷积

### 高斯滤波： 去掉噪点，但是会模糊图片

- **开运算：先腐蚀后膨胀，用于移除由图像噪声形成的斑点 ** 
  -  开运算能够除去孤立的小点，毛刺和小桥，而总的位置和形状不便。
  - 开运算是一个基于几何运算的滤波器。
  - 结构元素大小的不同将导致滤波效果的不同。
- 闭运算：先膨胀后腐蚀，用来连接被误分为许多小块的对象  当需要把细节更明显的时候使用 看上去将两个细微连接的图块封闭在一起,可以将边缘连接起来
  - 闭运算能够填平小湖（即小孔），弥合小裂缝，而总的位置和形状不变。
  - 闭运算是通过填充图像的凹角来滤波图像的
- 礼帽操作 = 原始输入-开运算（先腐蚀再膨胀）    礼帽操作是先对原图像进行膨胀操作，再用膨胀后的结果减去原图像得到。礼帽操作可以提取出比原图像暗且尺寸较小的细节或者噪声。**礼帽操作用于突出图像中的亮细节**
-  黑帽运算=闭运算结果（先膨胀再腐蚀）-原始输入  可以删除亮背景下的黑暗区域，用原图减去闭运算结果就可以得到原图中灰度较暗的区域，突出显示图像中的小暗区域。
- 梯度运算 = 膨胀 -腐蚀    用于求取轮廓    retval, dst = cv2.morphologyEx(src, op, kernel[, dst[, anchor]])   cv2.MORPH_GRADIENT：形态学梯度。膨胀图与腐蚀图之差   提取物体边缘

### 边缘检测：

- Canny  检测器的效果较好，更适合用于检测真正的弱边缘。
- Sobel算子很容易在空间上实现，边缘检测效果较好，且受噪声的影响也较小。邻域增大抗噪性会更好，但计算量也会增大，得出的边缘也会相应变粗。Sobel算子会检测出许多伪边缘，边缘定位精度不够高，在精度要求不高时是一种较常用的边缘检测方法。
- 拉普拉斯边缘检测算子是一种二阶微分算子，与其它边缘检测方法的不同之处在于，该方法是一种各向同性的检测方法，即其边缘的增强程度与边缘的方向无关，从而可以满足不同走向的边缘锐化的要求。

### 角点检测：

识别角点 

```
# 调用函数 cornerHarris，检测角点，其中参数 2 表示 Sobel 算子的孔径大小，23 表示 Sobel 算子的孔径大小，0.04 表示 Harris 角点检测方程中的 k 值
dst = cv2.cornerHarris(gray, 2, 23, 0.05)
```

### 特征匹配

1. Different of Gaussian(DoG) 对同一图像使用不同[高斯滤波](https://so.csdn.net/so/search?q=高斯滤波&spm=1001.2101.3001.7020)器

   ```
   sift = cv2.xfeatures2d.SIFT_create()#
   keypoints, descriptor = sift.detectAndCompute(gray,None)#返回关键点和描述符
    
   img = cv2.drawKeypoints(image=img, outImg=img, keypoints=keypoints,
                           flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINT,
                           color=(51,163,236))# 
   ```

   

2. **SURF**  加速的 使用比较少 效率提升有限  较少使用 flann 效果最好

   ```
   
   surf = cv2.xfeatures2d.SURF_create(8000)#阈值越小特征点越多
   keypoints, descriptor = surf.detectAndCompute(gray,None)#返回关键点和描述符
   img = cv2.drawKeypoints(image=img, outImg=img, keypoints=keypoints,
                           flags=4,
                           color=(51,163,236))# 
   ```

   

3. **ORB特征**  暴力检测

   ```
   
   # create the ORB detector
   orb = cv2.ORB_create()
   kp1, des1 = orb.detectAndCompute(img1,None)
   kp2, des2 = orb.detectAndCompute(img2,None)
    
   # brute force matching
   bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)#暴力匹配
   matches = bf.match(des1,des2)#
   #matches = bf.knnMatch(des1,des2,k=2)#knn匹配
    
   # Sort by distance.
   matches = sorted(matches, key = lambda x:x.distance)
   img3 = cv2.drawMatches(img1,kp1,img2,kp2, matches[:25], img2,flags=2)
   #img3 = cv2.drawMatchesKnn(img1,kp1,img2,kp2, matches[:25], img2,flags=2)#knn 
   ```

4. FLANN特征匹配

   ```
   # create SIFT and detect/compute
   sift = cv2.xfeatures2d.SIFT_create()
   kp1, des1 = sift.detectAndCompute(queryImage,None)
   kp2, des2 = sift.detectAndCompute(trainingImage,None)
    
   # FLANN matcher parameters
   # FLANN_INDEX_KDTREE = 0
   indexParams = dict(algorithm = 0, trees = 5)
   searchParams = dict(checks=50)   # or pass empty dictionary
    
   flann = cv2.FlannBasedMatcher(indexParams,searchParams)
    
   matches = flann.knnMatch(des1,des2,k=2)
    
   # prepare an empty mask to draw good matches
   matchesMask = [[0,0] for i in xrange(len(matches))]
    
   # David G. Lowe's ratio test, populate the mask
   for i,(m,n) in enumerate(matches):#enumerate枚举列举 例 enumerate(['a',(2,3)]) 
                                                           0 'a'
                                                           1 (2,3)
       if m.distance < 0.7*n.distance:#匹配过滤 丢弃距离大于0.7的值
           matchesMask[i]=[1,0]
    
   drawParams = dict(matchColor = (0,255,0),
                     singlePointColor = (255,0,0),
                     matchesMask = matchesMask,
                     flags = 0)
    
   resultImage = cv2.drawMatchesKnn(queryImage,kp1,trainingImage,kp2,matches,None,**drawParams)#收集参数 **变量存放的方式是字典 *元组
   ```

   





## 图像金字塔

- 高斯金字塔（Gaussian Pyramid）：高斯金字塔通过不断降采样（缩小）原始图像来构建，每一层图像都是前一层图像的一半大小。降采样可以通过平均像素值或使用高斯滤波器来实现。高斯金字塔在图像缩放、分割、模糊等任务中有用
- 拉普拉斯金字塔（Laplacian Pyramid）：拉普拉斯金字塔是通过从高斯金字塔中的每一层图像减去其上一层的上采样图像得到的。这一过程使得每一层图像包含了高频成分，即图像细节。拉普拉斯金字塔在图像增强、压缩、图像融合等方面有用。

虽然一幅图像在先后经过向下采样、向上采样后，会恢复为原始大小，但是向上采样和向下采样不是互逆的。也就是说，虽然在经历两次采样操作后，得到的结果图像与原始图像的大小一致，肉眼看起来也相似，但是二者的像素值并不是一致的





#### 傅里叶变换的作用：

- 高频  变化剧烈的灰度分量   会使得图像细节更强
- 低频 变化缓慢的灰度分量   会使得图像模糊

# 2.TesseractOCR

适用范围：

TesseractOCR 对定位到的区域内的内容进行识别。

安装：





3.easyocr

``` 
pip install easyocr
```

python 3.9.13    安装成功

## 色彩空间

###  YUV 
###  HSB
###  HSL  



# 材料

#### OpenCV例程300篇

https://youcans.blog.csdn.net/article/details/125112487
