# å›¾åƒè¯†åˆ«

-- å›¾åƒè¯†åˆ«æŠ€æœ¯çš„è¿‡ç¨‹åˆ†ä»¥ä¸‹å‡ æ­¥ï¼šä¿¡æ¯çš„è·å–ã€é¢„å¤„ç†ã€ç‰¹å¾æŠ½å–å’Œé€‰æ‹©ã€åˆ†ç±»å™¨è®¾è®¡å’Œåˆ†ç±»å†³ç­–ã€‚

 1.ä¿¡æ¯çš„è·å–æ˜¯æŒ‡é€šè¿‡ä¼ æ„Ÿå™¨ï¼Œå°†å…‰æˆ–å£°éŸ³ç­‰ä¿¡æ¯è½¬åŒ–ä¸ºç”µä¿¡æ¯ã€‚ä¹Ÿå°±æ˜¯è·å–ç ”ç©¶å¯¹è±¡çš„åŸºæœ¬ä¿¡æ¯å¹¶é€šè¿‡æŸç§æ–¹æ³•å°†å…¶è½¬å˜ä¸ºæœºå™¨èƒ½å¤Ÿè®¤è¯†çš„ä¿¡æ¯ã€‚
 2.é¢„å¤„ç†ä¸»è¦æ˜¯æŒ‡å›¾åƒå¤„ç†ä¸­çš„å»å™ªã€å¹³æ»‘ã€å˜æ¢ç­‰çš„æ“ä½œï¼Œä»è€ŒåŠ å¼ºå›¾åƒçš„é‡è¦ç‰¹å¾ã€‚
 3.ç‰¹å¾æŠ½å–å’Œé€‰æ‹©æ˜¯æŒ‡åœ¨æ¨¡å¼è¯†åˆ«ä¸­ï¼Œéœ€è¦è¿›è¡Œç‰¹å¾çš„æŠ½å–å’Œé€‰æ‹©ã€‚ç®€å•çš„ç†è§£å°±æ˜¯æˆ‘ä»¬æ‰€ç ”ç©¶çš„å›¾åƒæ˜¯å„å¼å„æ ·çš„ï¼Œå¦‚æœè¦åˆ©ç”¨æŸç§æ–¹æ³•å°†å®ƒä»¬åŒºåˆ†å¼€ï¼Œå°±è¦é€šè¿‡è¿™äº›å›¾åƒæ‰€å…·æœ‰çš„æœ¬èº«ç‰¹å¾æ¥è¯†åˆ«ï¼Œè€Œè·å–è¿™äº›ç‰¹å¾çš„è¿‡ç¨‹å°±æ˜¯ç‰¹å¾æŠ½å–ã€‚åœ¨ç‰¹å¾æŠ½å–ä¸­æ‰€å¾—åˆ°çš„ç‰¹å¾ä¹Ÿè®¸å¯¹æ­¤æ¬¡è¯†åˆ«å¹¶ä¸éƒ½æ˜¯æœ‰ç”¨çš„ï¼Œè¿™ä¸ªæ—¶å€™å°±è¦æå–æœ‰ç”¨çš„ç‰¹å¾ï¼Œè¿™å°±æ˜¯ç‰¹å¾çš„é€‰æ‹©ã€‚ç‰¹å¾æŠ½å–å’Œé€‰æ‹©åœ¨å›¾åƒè¯†åˆ«è¿‡ç¨‹ä¸­æ˜¯éå¸¸å…³é”®çš„æŠ€æœ¯ä¹‹ä¸€ï¼Œæ‰€ä»¥å¯¹è¿™ä¸€æ­¥çš„ç†è§£æ˜¯å›¾åƒè¯†åˆ«çš„é‡ç‚¹ã€‚
 4.åˆ†ç±»å™¨è®¾è®¡æ˜¯æŒ‡é€šè¿‡è®­ç»ƒè€Œå¾—åˆ°ä¸€ç§è¯†åˆ«è§„åˆ™ï¼Œé€šè¿‡æ­¤è¯†åˆ«è§„åˆ™å¯ä»¥å¾—åˆ°ä¸€ç§ç‰¹å¾åˆ†ç±»ï¼Œä½¿å›¾åƒè¯†åˆ«æŠ€æœ¯èƒ½å¤Ÿå¾—åˆ°é«˜è¯†åˆ«ç‡ã€‚åˆ†ç±»å†³ç­–æ˜¯æŒ‡åœ¨ç‰¹å¾ç©ºé—´ä¸­å¯¹è¢«è¯†åˆ«å¯¹è±¡è¿›è¡Œåˆ†ç±»ï¼Œä»è€Œæ›´å¥½åœ°è¯†åˆ«æ‰€ç ”ç©¶çš„å¯¹è±¡å…·ä½“å±äºå“ªä¸€ç±»ã€‚

é¢„å¤„ç†ç®—æ³•ï¼šæ»¤æ³¢ï¼›å›¾åƒå¢å¼ºï¼›å›¾åƒåˆ†å‰²ï¼›é¢„å¤„ç†ç®—æ³•ç»“æœï¼šæ„æˆè®­ç»ƒæ ·æœ¬å’Œæµ‹è¯•æ ·æœ¬ï¼›
ç‰¹å¾  æå–ï¼šå½¢çŠ¶è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ï¼›æå–å„é˜¶çŸ©ç‰¹å¾å€¼ï¼›ç‰¹å¾å€¼è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ï¼›è®­ç»ƒSVMå¾—å‚æ•°è®¾è®¡ç”µæ°”è®¾å¤‡çš„åˆ†ç±»å™¨ï¼›

 ç¥ç»ç½‘ç»œå›¾åƒè¯†åˆ«æŠ€æœ¯æ˜¯ä¸€ç§æ¯”è¾ƒæ–°å‹çš„å›¾åƒè¯†åˆ«æŠ€æœ¯ï¼Œæ˜¯åœ¨ä¼ ç»Ÿçš„å›¾åƒè¯†åˆ«æ–¹æ³•å’ŒåŸºç¡€ä¸Šèåˆç¥ç»ç½‘ç»œç®—æ³•çš„ä¸€ç§å›¾åƒè¯†åˆ«æ–¹æ³•ã€‚
 åœ¨å¯¹è½¦ç‰Œä¸Šçš„å­—ç¬¦è¿›è¡Œè¯†åˆ«çš„è¿‡ç¨‹ä¸­å°±ç”¨åˆ°äº†åŸºäºæ¨¡æ¿åŒ¹é…ç®—æ³•å’ŒåŸºäºäººå·¥ç¥ç»ç½‘ç»œç®—æ³•ã€‚æƒ³è®©è®¡ç®—æœºå…·æœ‰é«˜æ•ˆåœ°è¯†åˆ«èƒ½åŠ›ï¼Œæœ€ç›´æ¥æœ‰æ•ˆçš„æ–¹æ³•å°±æ˜¯é™ç»´ã€‚é™ç»´åˆ†ä¸ºçº¿æ€§é™ç»´å’Œéçº¿æ€§é™ç»´ã€‚ä¾‹å¦‚ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰å’Œçº¿æ€§å¥‡å¼‚åˆ†æï¼ˆLDAï¼‰ç­‰å°±æ˜¯å¸¸è§çš„çº¿æ€§é™ç»´æ–¹æ³•ï¼Œå®ƒä»¬çš„ç‰¹ç‚¹æ˜¯ç®€å•ã€æ˜“äºç†è§£ã€‚

# 1.OpenCV

é€‚ç”¨èŒƒå›´ï¼š

OpenCVç”¨æ¥åšå›¾åƒå¤„ç†ï¼Œå®šä½åˆ°èº«ä»½è¯å·ç çš„åŒºåŸŸ

å®‰è£…ï¼š

## 1. å›¾åƒçš„ä»¿å°„å˜æ¢

#### é€è§†å˜æ¢

å¯ä»¥å°†å›¾åƒä»ä¸€ä¸ªé€è§†æŠ•å½±è½¬æ¢ä¸ºå¦ä¸€ä¸ªé€è§†æŠ•å½±ï¼Œå®ç°å›¾åƒçš„æ—‹è½¬ã€ç¼©æ”¾ã€å¹³ç§»ç­‰æ“ä½œ

#### å•åº”æ€§çŸ©é˜µ

```
è¯¥å‡½æ•°å¯ä»¥æ ¹æ®è¾“å…¥çš„åæ ‡è·å–é€è§†å˜æ¢åçš„åæ ‡
findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask[, maxIters[, confidence]]]]]) -> H, mask
ï¼ˆ M = cv2.getPerspectiveTransform(src,dst) è¯¥å‡½æ•°ä¹Ÿå¯ä»¥è·å–é€è§†å˜æ¢çŸ©é˜µï¼‰
è®¡ç®—å¤šä¸ªäºŒç»´ç‚¹å¯¹ä¹‹é—´çš„æœ€ä¼˜å•åº”æ€§çŸ©é˜µ Hï¼ˆ3è¡Œx3åˆ—ï¼‰ ï¼Œä½¿ç”¨æœ€å°å‡æ–¹è¯¯å·®æˆ–è€…RANSACæ–¹æ³•ã€‚å‡½æ•°åŠŸèƒ½ï¼šæ‰¾åˆ°ä¸¤ä¸ªå¹³é¢ä¹‹é—´çš„è½¬æ¢çŸ©é˜µã€‚
```

```

è¯¥å‡½æ•°å¯ä»¥æ ¹æ®è¾“å…¥çš„åæ ‡è·å–é€è§†å˜æ¢åçš„åæ ‡
warpPerspective(src, H, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst

ï¼ˆ dst = cv2.perspectiveTransform(pts,H) ï¼‰

é€šè¿‡è¾“å…¥å˜æ¢çŸ©é˜µå¾—åˆ°é€è§†å›¾ç‰‡ã€‚

å‚æ•°è¯´æ˜ï¼š

src è¾“å…¥å›¾ç‰‡ï¼›dst è¾“å‡ºå›¾ç‰‡ã€‚
M è¾“å…¥çš„é€è§†å˜æ¢çŸ©é˜µï¼Œå¤§å°æ˜¯3*3
dsize è¾“å‡ºå›¾ç‰‡çš„å¤§å°
flags æ’å€¼æ–¹æ³•ï¼ˆINTER_LINEARæˆ–INTER_NEARESTï¼‰ä¸å¯é€‰æ ‡å¿—WARP_INVERSE_MAPçš„ç»„åˆï¼Œå°†Mè®¾ç½®ä¸ºé€†å˜æ¢ï¼ˆğšğšœğšâ†’ğšœğš›ğšŒï¼‰ã€‚
borderMode è¾¹ç•Œåƒç´ èµ‹å€¼æ“ä½œ(BORDER_CONSTANT or BORDER_REPLICATE)ï¼Œå‰è€…æ˜¯å®šå€¼ï¼Œåè€…æ˜¯å¤åˆ¶å‘¨å›´åƒç´ ã€‚
```









## å·ç§¯

### é«˜æ–¯æ»¤æ³¢ï¼š å»æ‰å™ªç‚¹ï¼Œä½†æ˜¯ä¼šæ¨¡ç³Šå›¾ç‰‡

- **å¼€è¿ç®—ï¼šå…ˆè…èš€åè†¨èƒ€ï¼Œç”¨äºç§»é™¤ç”±å›¾åƒå™ªå£°å½¢æˆçš„æ–‘ç‚¹ ** 
  -  å¼€è¿ç®—èƒ½å¤Ÿé™¤å»å­¤ç«‹çš„å°ç‚¹ï¼Œæ¯›åˆºå’Œå°æ¡¥ï¼Œè€Œæ€»çš„ä½ç½®å’Œå½¢çŠ¶ä¸ä¾¿ã€‚
  - å¼€è¿ç®—æ˜¯ä¸€ä¸ªåŸºäºå‡ ä½•è¿ç®—çš„æ»¤æ³¢å™¨ã€‚
  - ç»“æ„å…ƒç´ å¤§å°çš„ä¸åŒå°†å¯¼è‡´æ»¤æ³¢æ•ˆæœçš„ä¸åŒã€‚
- é—­è¿ç®—ï¼šå…ˆè†¨èƒ€åè…èš€ï¼Œç”¨æ¥è¿æ¥è¢«è¯¯åˆ†ä¸ºè®¸å¤šå°å—çš„å¯¹è±¡  å½“éœ€è¦æŠŠç»†èŠ‚æ›´æ˜æ˜¾çš„æ—¶å€™ä½¿ç”¨ çœ‹ä¸Šå»å°†ä¸¤ä¸ªç»†å¾®è¿æ¥çš„å›¾å—å°é—­åœ¨ä¸€èµ·,å¯ä»¥å°†è¾¹ç¼˜è¿æ¥èµ·æ¥
  - é—­è¿ç®—èƒ½å¤Ÿå¡«å¹³å°æ¹–ï¼ˆå³å°å­”ï¼‰ï¼Œå¼¥åˆå°è£‚ç¼ï¼Œè€Œæ€»çš„ä½ç½®å’Œå½¢çŠ¶ä¸å˜ã€‚
  - é—­è¿ç®—æ˜¯é€šè¿‡å¡«å……å›¾åƒçš„å‡¹è§’æ¥æ»¤æ³¢å›¾åƒçš„
- ç¤¼å¸½æ“ä½œ = åŸå§‹è¾“å…¥-å¼€è¿ç®—ï¼ˆå…ˆè…èš€å†è†¨èƒ€ï¼‰    ç¤¼å¸½æ“ä½œæ˜¯å…ˆå¯¹åŸå›¾åƒè¿›è¡Œè†¨èƒ€æ“ä½œï¼Œå†ç”¨è†¨èƒ€åçš„ç»“æœå‡å»åŸå›¾åƒå¾—åˆ°ã€‚ç¤¼å¸½æ“ä½œå¯ä»¥æå–å‡ºæ¯”åŸå›¾åƒæš—ä¸”å°ºå¯¸è¾ƒå°çš„ç»†èŠ‚æˆ–è€…å™ªå£°ã€‚**ç¤¼å¸½æ“ä½œç”¨äºçªå‡ºå›¾åƒä¸­çš„äº®ç»†èŠ‚**
-  é»‘å¸½è¿ç®—=é—­è¿ç®—ç»“æœï¼ˆå…ˆè†¨èƒ€å†è…èš€ï¼‰-åŸå§‹è¾“å…¥  å¯ä»¥åˆ é™¤äº®èƒŒæ™¯ä¸‹çš„é»‘æš—åŒºåŸŸï¼Œç”¨åŸå›¾å‡å»é—­è¿ç®—ç»“æœå°±å¯ä»¥å¾—åˆ°åŸå›¾ä¸­ç°åº¦è¾ƒæš—çš„åŒºåŸŸï¼Œçªå‡ºæ˜¾ç¤ºå›¾åƒä¸­çš„å°æš—åŒºåŸŸã€‚
- æ¢¯åº¦è¿ç®— = è†¨èƒ€ -è…èš€    ç”¨äºæ±‚å–è½®å»“    retval, dst = cv2.morphologyEx(src, op, kernel[, dst[, anchor]])   cv2.MORPH_GRADIENTï¼šå½¢æ€å­¦æ¢¯åº¦ã€‚è†¨èƒ€å›¾ä¸è…èš€å›¾ä¹‹å·®   æå–ç‰©ä½“è¾¹ç¼˜

### è¾¹ç¼˜æ£€æµ‹ï¼š

- Canny  æ£€æµ‹å™¨çš„æ•ˆæœè¾ƒå¥½ï¼Œæ›´é€‚åˆç”¨äºæ£€æµ‹çœŸæ­£çš„å¼±è¾¹ç¼˜ã€‚
- Sobelç®—å­å¾ˆå®¹æ˜“åœ¨ç©ºé—´ä¸Šå®ç°ï¼Œè¾¹ç¼˜æ£€æµ‹æ•ˆæœè¾ƒå¥½ï¼Œä¸”å—å™ªå£°çš„å½±å“ä¹Ÿè¾ƒå°ã€‚é‚»åŸŸå¢å¤§æŠ—å™ªæ€§ä¼šæ›´å¥½ï¼Œä½†è®¡ç®—é‡ä¹Ÿä¼šå¢å¤§ï¼Œå¾—å‡ºçš„è¾¹ç¼˜ä¹Ÿä¼šç›¸åº”å˜ç²—ã€‚Sobelç®—å­ä¼šæ£€æµ‹å‡ºè®¸å¤šä¼ªè¾¹ç¼˜ï¼Œè¾¹ç¼˜å®šä½ç²¾åº¦ä¸å¤Ÿé«˜ï¼Œåœ¨ç²¾åº¦è¦æ±‚ä¸é«˜æ—¶æ˜¯ä¸€ç§è¾ƒå¸¸ç”¨çš„è¾¹ç¼˜æ£€æµ‹æ–¹æ³•ã€‚
- æ‹‰æ™®æ‹‰æ–¯è¾¹ç¼˜æ£€æµ‹ç®—å­æ˜¯ä¸€ç§äºŒé˜¶å¾®åˆ†ç®—å­ï¼Œä¸å…¶å®ƒè¾¹ç¼˜æ£€æµ‹æ–¹æ³•çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œè¯¥æ–¹æ³•æ˜¯ä¸€ç§å„å‘åŒæ€§çš„æ£€æµ‹æ–¹æ³•ï¼Œå³å…¶è¾¹ç¼˜çš„å¢å¼ºç¨‹åº¦ä¸è¾¹ç¼˜çš„æ–¹å‘æ— å…³ï¼Œä»è€Œå¯ä»¥æ»¡è¶³ä¸åŒèµ°å‘çš„è¾¹ç¼˜é”åŒ–çš„è¦æ±‚ã€‚

### è§’ç‚¹æ£€æµ‹ï¼š

è¯†åˆ«è§’ç‚¹ 

```
# è°ƒç”¨å‡½æ•° cornerHarrisï¼Œæ£€æµ‹è§’ç‚¹ï¼Œå…¶ä¸­å‚æ•° 2 è¡¨ç¤º Sobel ç®—å­çš„å­”å¾„å¤§å°ï¼Œ23 è¡¨ç¤º Sobel ç®—å­çš„å­”å¾„å¤§å°ï¼Œ0.04 è¡¨ç¤º Harris è§’ç‚¹æ£€æµ‹æ–¹ç¨‹ä¸­çš„ k å€¼
dst = cv2.cornerHarris(gray, 2, 23, 0.05)
```

### ç‰¹å¾åŒ¹é…

1. Different of Gaussian(DoG) å¯¹åŒä¸€å›¾åƒä½¿ç”¨ä¸åŒ[é«˜æ–¯æ»¤æ³¢](https://so.csdn.net/so/search?q=é«˜æ–¯æ»¤æ³¢&spm=1001.2101.3001.7020)å™¨

   ```
   sift = cv2.xfeatures2d.SIFT_create()#
   keypoints, descriptor = sift.detectAndCompute(gray,None)#è¿”å›å…³é”®ç‚¹å’Œæè¿°ç¬¦
    
   img = cv2.drawKeypoints(image=img, outImg=img, keypoints=keypoints,
                           flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINT,
                           color=(51,163,236))# 
   ```

   

2. **SURF**  åŠ é€Ÿçš„ ä½¿ç”¨æ¯”è¾ƒå°‘ æ•ˆç‡æå‡æœ‰é™  è¾ƒå°‘ä½¿ç”¨ flann æ•ˆæœæœ€å¥½

   ```
   
   surf = cv2.xfeatures2d.SURF_create(8000)#é˜ˆå€¼è¶Šå°ç‰¹å¾ç‚¹è¶Šå¤š
   keypoints, descriptor = surf.detectAndCompute(gray,None)#è¿”å›å…³é”®ç‚¹å’Œæè¿°ç¬¦
   img = cv2.drawKeypoints(image=img, outImg=img, keypoints=keypoints,
                           flags=4,
                           color=(51,163,236))# 
   ```

   

3. **ORBç‰¹å¾**  æš´åŠ›æ£€æµ‹

   ```
   
   # create the ORB detector
   orb = cv2.ORB_create()
   kp1, des1 = orb.detectAndCompute(img1,None)
   kp2, des2 = orb.detectAndCompute(img2,None)
    
   # brute force matching
   bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)#æš´åŠ›åŒ¹é…
   matches = bf.match(des1,des2)#
   #matches = bf.knnMatch(des1,des2,k=2)#knnåŒ¹é…
    
   # Sort by distance.
   matches = sorted(matches, key = lambda x:x.distance)
   img3 = cv2.drawMatches(img1,kp1,img2,kp2, matches[:25], img2,flags=2)
   #img3 = cv2.drawMatchesKnn(img1,kp1,img2,kp2, matches[:25], img2,flags=2)#knn 
   ```

4. FLANNç‰¹å¾åŒ¹é…

   ```
   # create SIFT and detect/compute
   sift = cv2.xfeatures2d.SIFT_create()
   kp1, des1 = sift.detectAndCompute(queryImage,None)
   kp2, des2 = sift.detectAndCompute(trainingImage,None)
    
   # FLANN matcher parameters
   # FLANN_INDEX_KDTREE = 0
   indexParams = dict(algorithm = 0, trees = 5)
   searchParams = dict(checks=50)   # or pass empty dictionary
    
   flann = cv2.FlannBasedMatcher(indexParams,searchParams)
    
   matches = flann.knnMatch(des1,des2,k=2)
    
   # prepare an empty mask to draw good matches
   matchesMask = [[0,0] for i in xrange(len(matches))]
    
   # David G. Lowe's ratio test, populate the mask
   for i,(m,n) in enumerate(matches):#enumerateæšä¸¾åˆ—ä¸¾ ä¾‹ enumerate(['a',(2,3)]) 
                                                           0 'a'
                                                           1 (2,3)
       if m.distance < 0.7*n.distance:#åŒ¹é…è¿‡æ»¤ ä¸¢å¼ƒè·ç¦»å¤§äº0.7çš„å€¼
           matchesMask[i]=[1,0]
    
   drawParams = dict(matchColor = (0,255,0),
                     singlePointColor = (255,0,0),
                     matchesMask = matchesMask,
                     flags = 0)
    
   resultImage = cv2.drawMatchesKnn(queryImage,kp1,trainingImage,kp2,matches,None,**drawParams)#æ”¶é›†å‚æ•° **å˜é‡å­˜æ”¾çš„æ–¹å¼æ˜¯å­—å…¸ *å…ƒç»„
   ```

   





## å›¾åƒé‡‘å­—å¡”

- é«˜æ–¯é‡‘å­—å¡”ï¼ˆGaussian Pyramidï¼‰ï¼šé«˜æ–¯é‡‘å­—å¡”é€šè¿‡ä¸æ–­é™é‡‡æ ·ï¼ˆç¼©å°ï¼‰åŸå§‹å›¾åƒæ¥æ„å»ºï¼Œæ¯ä¸€å±‚å›¾åƒéƒ½æ˜¯å‰ä¸€å±‚å›¾åƒçš„ä¸€åŠå¤§å°ã€‚é™é‡‡æ ·å¯ä»¥é€šè¿‡å¹³å‡åƒç´ å€¼æˆ–ä½¿ç”¨é«˜æ–¯æ»¤æ³¢å™¨æ¥å®ç°ã€‚é«˜æ–¯é‡‘å­—å¡”åœ¨å›¾åƒç¼©æ”¾ã€åˆ†å‰²ã€æ¨¡ç³Šç­‰ä»»åŠ¡ä¸­æœ‰ç”¨
- æ‹‰æ™®æ‹‰æ–¯é‡‘å­—å¡”ï¼ˆLaplacian Pyramidï¼‰ï¼šæ‹‰æ™®æ‹‰æ–¯é‡‘å­—å¡”æ˜¯é€šè¿‡ä»é«˜æ–¯é‡‘å­—å¡”ä¸­çš„æ¯ä¸€å±‚å›¾åƒå‡å»å…¶ä¸Šä¸€å±‚çš„ä¸Šé‡‡æ ·å›¾åƒå¾—åˆ°çš„ã€‚è¿™ä¸€è¿‡ç¨‹ä½¿å¾—æ¯ä¸€å±‚å›¾åƒåŒ…å«äº†é«˜é¢‘æˆåˆ†ï¼Œå³å›¾åƒç»†èŠ‚ã€‚æ‹‰æ™®æ‹‰æ–¯é‡‘å­—å¡”åœ¨å›¾åƒå¢å¼ºã€å‹ç¼©ã€å›¾åƒèåˆç­‰æ–¹é¢æœ‰ç”¨ã€‚

è™½ç„¶ä¸€å¹…å›¾åƒåœ¨å…ˆåç»è¿‡å‘ä¸‹é‡‡æ ·ã€å‘ä¸Šé‡‡æ ·åï¼Œä¼šæ¢å¤ä¸ºåŸå§‹å¤§å°ï¼Œä½†æ˜¯å‘ä¸Šé‡‡æ ·å’Œå‘ä¸‹é‡‡æ ·ä¸æ˜¯äº’é€†çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè™½ç„¶åœ¨ç»å†ä¸¤æ¬¡é‡‡æ ·æ“ä½œåï¼Œå¾—åˆ°çš„ç»“æœå›¾åƒä¸åŸå§‹å›¾åƒçš„å¤§å°ä¸€è‡´ï¼Œè‚‰çœ¼çœ‹èµ·æ¥ä¹Ÿç›¸ä¼¼ï¼Œä½†æ˜¯äºŒè€…çš„åƒç´ å€¼å¹¶ä¸æ˜¯ä¸€è‡´çš„





#### å‚…é‡Œå¶å˜æ¢çš„ä½œç”¨ï¼š

- é«˜é¢‘  å˜åŒ–å‰§çƒˆçš„ç°åº¦åˆ†é‡   ä¼šä½¿å¾—å›¾åƒç»†èŠ‚æ›´å¼º
- ä½é¢‘ å˜åŒ–ç¼“æ…¢çš„ç°åº¦åˆ†é‡   ä¼šä½¿å¾—å›¾åƒæ¨¡ç³Š

# 2.TesseractOCR

é€‚ç”¨èŒƒå›´ï¼š

TesseractOCR å¯¹å®šä½åˆ°çš„åŒºåŸŸå†…çš„å†…å®¹è¿›è¡Œè¯†åˆ«ã€‚

å®‰è£…ï¼š





3.easyocr

``` 
pip install easyocr
```

python 3.9.13    å®‰è£…æˆåŠŸ

## è‰²å½©ç©ºé—´

###  YUV 
###  HSB
###  HSL  



# ææ–™

#### OpenCVä¾‹ç¨‹300ç¯‡

https://youcans.blog.csdn.net/article/details/125112487
